# Algorithms-and-Data-structures

Здесь собраны решения к задачам из первого контеста.

## [Задача A - Компоненты связности.](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/A.cpp)

Дан неориентированный невзвешенный граф. Необходимо посчитать количество его компонент связности и вывести их.

### Input format

Во входном файле записано два числа N и M (1 ≤ N ≤ 100000, 0 ≤ M ≤ 100000). В следующих M строках записаны по два числа i и j (1 ≤ i, j ≤ N), которые означают, что вершины i и j соединены ребром.

### Output format

В первой строчке выходного файла выведите количество компонент связности. Далее выведите сами компоненты связности в следующем формате: в первой строке количество вершин в компоненте, во второй — сами вершины в произвольном порядке.


## [Задача B - Долой списывание!](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/B.cpp)

Во время контрольной работы профессор Флойд заметил, что некоторые студенты обмениваются записками. Сначала он хотел поставить им всем двойки, но в тот день профессор был добрым, а потому решил разделить студентов на две группы: списывающих и дающих списывать, и поставить двойки только первым.

У профессора записаны все пары студентов, обменявшихся записками. Требуется определить, сможет ли он разделить студентов на две группы так, чтобы любой обмен записками осуществлялся от студента одной группы студенту другой группы.

### Input format

В первой строке находятся два числа N и M — количество студентов и количество пар студентов, обменивающихся записками (1 ≤ N ≤ 100, 0 ≤ M ≤ N*(N−1)/2). Далее в M строках расположены описания пар студентов: два числа, соответствующие номерам студентов, обменивающихся записками (нумерация студентов идёт с 1). Каждая пара студентов перечислена не более одного раза.

### Output format

Необходимо вывести ответ на задачу профессора Флойда. Если возможно разделить студентов на две группы — выведите «YES»; иначе выведите «NO».


## [Задача C - Поиск цикла](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/C.cpp)

Дан ориентированный невзвешенный граф. Необходимо определить есть ли в нём циклы, и если есть, то вывести любой из них.

### Input format

В первой строке входного файла находятся два натуральных числа N и M (1 ≤ N ≤ 100000, M ≤ 100000) - количество вершин и рёбер в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел - номерами начальной и конечной вершин соответственно.

### Output format

Если в графе нет цикла, то вывести "NO", иначе - "YES" и затем перечислить все вершины в порядке обхода цикла.


## [Задача D - Топологическая сортировка](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/D.cpp)

Дан ориентированный невзвешенный граф. Необходимо его топологически отсортировать.

### Input format

В первой строке входного файла даны два целых числа N и M (1 ≤ N ≤ 100000, 0 ≤ M ≤ 100000) - количества вершин и рёбер в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел - номерами начальной и конечной вершин соответственно.

### Output format

Вывести любую топологическую сортировку графа в виде последовательности номеров вершин. Если граф невозможно топологически отсортировать, вывести -1.


## [Задача E - Свинки-копилки](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/E.cpp)

У Васи есть N свинок-копилок, свинки занумерованы числами от 1 до N. Каждая копилка может быть открыта единственным соответствующим ей ключом или разбита.

Вася положил ключи в некоторые из копилок (он помнит, какой ключ лежит в какой из копилок). Теперь Вася собрался купить машину, а для этого ему нужно достать деньги из всех копилок. При этом он хочет разбить как можно меньшее количество копилок (ведь ему еще нужно копить деньги на квартиру, дачу, вертолет…). Помогите Васе определить, какое минимальное количество копилок нужно разбить.

### Input format

В первой строке содержится число N — количество свинок-копилок (1 ≤ N ≤ 100). Далее идет N строк с описанием того, где лежит ключ от какой копилки: в i-ой из этих строк записан номер копилки, в которой находится ключ от i-ой копилки.

### Output format

Выведите единственное число: минимальное количество копилок, которые необходимо разбить.


## [Задача F - Конденсация](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/F.cpp)

Вам задан ориентированный граф с N вершинами и M ребрами (1 ≤ N ≤ 20000, 1 ≤ M ≤ 200000). Найдите компоненты сильной связности заданного графа и топологически отсортируйте его конденсацию.

### Input format

Граф задан во входном файле следующим образом: первая строка содержит числа N и M. Каждая из следующих M строк содержит описание ребра — два целых числа из диапазона от 1 до N — номера начала и конца ребра.

### Output format

На первой строке выведите число K — количество компонент сильной связности в заданном графе. На следующей строке выведите N чисел — для каждой вершины выведите номер компоненты сильной связности, которой принадлежит эта вершина. Компоненты сильной связности должны быть занумерованы таким образом, чтобы для любого ребра номер компоненты сильной связности его начала не превышал номера компоненты сильной связности его конца.


## [Задача G - Кратчайшее расстояние v.0.1](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/G.cpp)

Вам дан неориентированный граф. Найдите кратчайший путь от вершины a до вершины b.

### Input format

В первой строке входного файла идут целые числа n и m (1 ≤ n ≤ 50000, 1 ≤ m ≤ 100000) количества вершин и рёбер соответственно. Во второй строке идут целые числа a и b - стартовая и конечная вершины соответственно. Далее идут m строк, описывающих рёбра.

### Output format

Если пути между a и b нет, выведите единственное число -1. Иначе выведите в первой строке число l - длину кратчайшего пути между этими двумя вершинами в рёбрах, а во второй строке выведите l + 1 число - вершины этого пути.


## [Задача H - Один конь](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/H.cpp)

На шахматной доске NxN в клетке (x1, y1) стоит голодный шахматный конь. Он хочет попасть в клетку (x2, y2), где растет вкусная шахматная трава. Какое наименьшее количество ходов он должен для этого сделать?

### Input format

На вход программы поступает пять чисел: N, x1, y1, x2, y2 (5 ≤ N ≤ 20, 1 ≤ x1, y1, x2, y2 ≤ N). Левая верхняя клетка доски имеет координаты (1, 1), правая нижняя — (N, N).

### Output format

В первой строке выведите единственное число K — наименьшее необходимое число ходов коня. В каждой из следующих K+1 строк должно быть записано 2 числа — координаты очередной клетки в пути коня.


## [Задача I - Числа](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/I.cpp)

Витя хочет придумать новую игру с числами. В этой игре от игроков требуется преобразовывать четырехзначные числа не содержащие нулей при помощи следующего разрешенного набора действий:

1. Можно увеличить первую цифру числа на 1, если она не равна 9.

2. Можно уменьшить последнюю цифру на 1, если она не равна 1.

3. Можно циклически сдвинуть все цифры на одну вправо.

4. Можно циклически сдвинуть все цифры на одну влево.

Например, применяя эти правила к числу 1234 можно получить числа 2234, 1233, 4123 и 2341 соответственно. Точные правила игры Витя пока не придумал, но пока его интересует вопрос, как получить из одного числа другое за минимальное количество операций.

### Input format

Во входном файле содержится два различных четырехзначных числа, каждое из которых не содержит нулей.

### Output format

Программа должна вывести последовательность четырехзначных чисел, не содержащих нулей. Последовательность должна начинаться первым из данных чисел и заканчиваться вторым из данных чисел, каждое последующее число в последовательности должно быть получено из предыдущего числа применением одного из правил. Количество чисел в последовательности должно быть минимально возможным.


## [Задача J - Табличка](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/J.cpp)

Дана таблица, состоящая из N строк и M столбцов. В каждой клетке таблицы записано одно из чисел: 0 или 1. Расстоянием между клетками (x1, y1) и (x2, y2) назовем сумму |x1-x2|+|y1-y2|. Вам необходимо построить таблицу, в клетке (i, j) которой будет записано минимальное расстояние между клеткой (i, j) начальной таблицы и клеткой, в которой записана 1. Гарантируется, что хотя бы одна 1 в таблице есть.

### Input format

В первой строке вводятся два натуральных числа N и M, не превосходящих 100. Далее идут N строк по M чисел — элементы таблицы.

### Output format

Требуется вывести N строк по M чисел — элементы искомой таблицы.


## [Задача K - Гонки](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/K.cpp)

На день рождения юному технику Мише подарили машинку с радиоуправлением. Мише быстро наскучило гонять машинку туда-сюда по комнате, и он соорудил специальную трассу. Для этого он разбил комнату на квадратные ячейки, некоторые из них оставив пустыми, а в некоторые поставив препятствия. Целую неделю Миша каждый день улучшал свой рекорд по прохождению трассы. Но каково же было разочарование Миши, когда к нему в гости пришел Тима со своей машинкой и побил его рекорд. Стало понятно, что машинку необходимо модернизировать. На пробных испытаниях, которые были произведены через день, Миша обнаружил, что машинка действительно ездит лучше, однако ее поведение несколько изменилось. На пульте теперь функционируют только четыре кнопки: вперед, назад, вправо, влево. При нажатии на них машинка едет по направлению к соответствующей стене комнаты, являющейся одновременно границей трассы, точно перпендикулярно ей. Машинка разгоняется до такой скорости, что перестает реагировать на другие команды, врезается в ближайшее препятствие или стену и отскакивает от нее на половину пройденного расстояния, то есть если между машинкой и стеной было x пустых клеток, то после отскока она остановится на клетке, от которой  клеток до стены x/2 клеток до стены. Теперь Мише интересно, какое минимальное количество раз необходимо нажать на кнопку пульта, чтобы машинка, начав в клетке старта, остановилась в клетке финиша.

### Input format

Первая строка входного файла содержит два целых числа n и m — размеры трассы (2 ≤ m,n ≤ 20). Следующие n строк содержат по m символов каждая: символ «.» соответствует пустой клетке, «#» — препятствию, а «S» и «T» — клетке старта и клетке финиша соответственно.

### Output format

В выходной файл выведите минимальное количество нажатий на кнопки пульта для проведения машинки по трассе от старта до финиша.
Если доехать от старта до финиша невозможно, выведите -1.


## [Задача L - Мосты](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/L.cpp)

Дан неориентированный граф. Требуется найти все мосты в нём.

### Input format

Первая строка входного файла содержит два натуральных числа n и m — количества вершин и рёбер графа соответственно (1 ≤ n ≤ 20000, 1 ≤ m ≤ 200000).

Следующие m строк содержат описание рёбер по одному на строке. Ребро номер i описывается двумя натуральными числами b_i, e_i — номерами концов ребра (1 ≤ b_i,e_i ≤ n).

### Output format

Первая строка выходного файла должна содержать одно натуральное число b — количество мостов в заданном графе. На следующих b строках выведите b целых чисел — номера рёбер, которые являются мостами, в возрастающем порядке. Рёбра нумеруются с единицы в том порядке, в котором они заданы во входном файле.


## [Задача M - Точки сочленения](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/M.cpp)

Дан неориентированный граф. Требуется найти все точки сочленения в нём.

### Input format

Первая строка входного файла содержит два натуральных числа n и m — количества вершин и рёбер графа соответственно (1 ≤ n ≤ 20000, 1 ≤ m ≤ 200000).

Ребро номер i описывается двумя натуральными числами b_i, e_i — номерами концов ребра (1 ≤ b_i,e_i ≤ n).

### Output format

Первая строка выходного файла должна содержать одно натуральное число b — количество точек сочленения в заданном графе. На следующих b строках выведите b целых чисел — номера вершин, которые являются точками сочленения, в возрастающем порядке.


## [Задача N - Острова](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/N.cpp)

Одно разбросанное на островах Океании государство решило создать сеть автомобильных дорог (вернее, мостов). По каждому мосту можно перемещаться в обе стороны. Был разработан план очередности строительства мостов и известно, что после постройки всех мостов можно будет проехать по ним с каждого острова на каждый (возможно, через некоторые промежуточные острова).

Однако, этот момент может наступить до того, как будут построены все мосты. Ваша задача состоит такое минимальное количество мостов, после постройки которых (в порядке строительства по плану) можно будет попасть с любого острова на любой другой.

### Input format

Первая строка содержит два числа: N — число островов (1 ≤ N ≤ 100000) и M — количество мостов в плане (1 ≤ M ≤ 200000). В каждой следующей строке содержится описание моста – два числа x и y (0 ≤ x, y ≤ N-1) – номера соединяемых островов.

### Output format

Выведите в выходной файл одно число – минимальное количество построенных мостов, по которым можно попасть с любого острова на любой.


## [Задача O - Вес компоненты](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/O.cpp)

В неориентированный взвешанный граф добавляют ребра. Напишите программу, которая в некоторые моменты находит сумму весов ребер в компоненте связности.

### Input format

В первой строке записано два числа n и m (1 ≤ n,m ≤ 10^6) - количество вершин в графе и количество производимых добавлений и запросов. Далее следует m строк с описанием добавления или запроса. Каждая строка состоит из двух или четырех чисел. Первое из чисел обозначает код операции. Если первое число 1, то за ним следует еще три числа x, y, w. Это означает, что в граф добавляется ребро из вершины x в вершину y веса w. (1 ≤ x < y ≤ n, 1 ≤ w ≤ 1000). Кратные ребра допустимы. Если первое число 2, то за ним следует ровно одно число x. Это означает, что необходимо ответить на вопрос, какова сумма ребер в компоненте связности, которой принадлежит вершина x (1 ≤ x ≤ n).

### Output format

Для каждой операции с кодом 2 выведите ответ на поставленную задачу. Ответ на каждый запрос выводите на отдельной строке.


## [Задача P - Остовное дерево](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/P.cpp)

Требуется найти в связном графе остовное дерево минимального веса.

### Input format

Первая строка входного файла содержит два натуральных числа n и m — количество вершин и ребер графа соответственно (1 ≤ n ≤ 20000, 0 ≤ m ≤ 100000). Следующие m строк содержат описание ребер по одному на строке. Ребро номер i описывается тремя натуральными числами b_i, e_i и w_i — номера концов ребра и его вес соответственно (1 ≤ b_i,e_i ≤ n, 0 ≤ w_i ≤ 100000).

Граф является связным.

### Output format

Выведите единственное целое число — вес минимального остовного дерева.

## [Задача Q - Шпионы](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/Q.cpp)

Вы - глава агенства, в котором работает N сотрудников - шпионы с кодовыми номерами от 1 до N. Шпионы были посланы в различные страны и получили кусочки важной информации. Ваша задача состоит в следующем:

1. Организовать встречи между некоторыми шпионами. На каждой такой встрече ровно два шпиона оказываются в одном месте и обмениваются всей информацией, которую получили сами или узнали от других шпионов на предыдущих встречах. Каждую из возможных встреч сложно и затратно организовать, поэтому вам известны все стоимости.

2. После того, как все встречи состоялись, выбирается группа шпионов, и они посылаются на задание по спасению мира. Для каждого шпиона известно, сколько денег он изведет, если его включить в эту группу. Задание должно быть выполнено, поэтому очень важно, чтобы выбранные шпионы все вместе обладали всей информацией, полученной агенством.

Найдите минимальную цену, за которую можно спасти мир.

### Input format

Первая строка содержит натуральное число N - количество шпионов (2 ≤ N ≤ 1000). Каждая из следующих строк содержит N натуральных чисел, не превосходящих 106. Число в k-ой строке и m-ом столбце обозначает стоимость встречи между шпионами k и m и совпадает с числом в m-ой строке и k-ом столбце (если k=m, то соответствующее число будет равно 0). Следующая строка содержит n чисел, i-ое из них равно стоимости послать i-го шпиона на задание. Все стоимости являются положительными целыми числами.

### Output format

Выведите одно число - минимальную стоимость спасения мира.


## [Задача S - Форд-Беллман](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/S.cpp)

Дан ориентированный граф, в котором могут быть кратные ребра и петли. Каждое ребро имеет вес, выражающийся целым числом (возможно, отрицательным). Гарантируется, что циклы отрицательного веса отсутствуют.

Требуется посчитать длины кратчайших путей от вершины номер 1 до всех остальных вершин.

### Input format

Программа получает сначала число N (1 ≤ N ≤ 100) – количество вершин графа и число M (0 ≤ M ≤ 10000) – количество ребер. В следующих строках идет M троек чисел, описывающих ребра: начало ребра, конец ребра и вес (вес – целое число от -100 до 100).

### Output format

Программа должна вывести N чисел – расстояния от вершины номер 1 до всех вершин графа. Если пути до соответствующей вершины не существует, вместо длины пути выведите число 30000.


## [Задача T - Цикл отрицательного веса](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/T.cpp)

ан ориентированный граф. Определить, есть ли в нем цикл отрицательного веса, и если да, то вывести его.

### Input format

В первой строке содержится число N (1 ≤ N ≤ 100) – количество вершин графа. В следующих N строках находится по N чисел – матрица смежности графа. Веса ребер по модулю меньше 100000. Если ребра нет, соответствующее значение равно 100000.

### Output format

В первой строке выведите "YES", если цикл существует, или "NO", в противном случае. При наличии цикла выведите во второй строке количество вершин в нем (считая одинаковые – первую и последнюю), а в третьей строке – вершины, входящие в этот цикл, в порядке обхода. Если циклов несколько, то выведите любой из них.


## [Задача U - Авиаперелеты](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/U.cpp)

Профессору Форду необходимо попасть на международную конференцию. Он хочет потратить на дорогу наименьшее количество денег, поэтому решил, что будет путешествовать исключительно ночными авиарейсами (чтобы не тратиться на ночевку в отелях), а днем будет осматривать достопримечательности тех городов, через которые он будет проезжать транзитом. Он внимательно изучил расписание авиаперелетов и составил набор подходящих авиарейсов, выяснив, что перелеты на выбранных направлениях совершаются каждую ночь и за одну ночь он не сможет совершить два перелета.

Теперь профессор хочет найти путь наименьшей стоимости, учитывая что до конференции осталось K ночей (то есть профессор может совершить не более K перелетов).

### Input format

В первой строке находятся числа N (количество городов), M (количество авиарейсов), K (количество оставшихся ночей), S (номер города, в котором живет профессор), F (номер города, в котором проводится конференция).

Ограничения: 2 ≤ N ≤ 100, 1 ≤ M ≤ 10^5, 1 ≤ K ≤ 100, 1 ≤ S ≤ N, 1 ≤ F ≤ N.

Далее идет M строк, задающих расписание авиарейсов. i-я строка содержит три натуральных числа: S_i, F_i и P_i, где S_i - номер города, из которого вылетает i-й рейс, F_i - номер города, в который прилетает i-й рейс, P_i - стоимость перелета i-м рейсом. 1 ≤ S_i ≤ N, 1 ≤ F_i ≤ N, 1 ≤ P_i ≤ 10^6.

### Output format

Выведите одно число - минимальную стоимость пути, подходящего для профессора. Если профессор не сможет за K ночей добраться до конференции, выведите число -1.


## [Задача V - Рейсы во времени](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/V.cpp)

Между N населенными пунктами совершаются пассажирские рейсы на машинах времени.

В момент времени 0 вы находитесь в пункте A. Вам дано расписание рейсов. Требуется оказаться в пункте B как можно раньше (то есть в наименьший возможный момент времени).

При этом разрешается делать пересадки с одного рейса на другой. Если вы прибываете в некоторый пункт в момент времени T, то вы можете уехать из него любым рейсом, который отправляется из этого пункта в момент времени T или позднее (но не раньше).

### Input format

В первой строке вводится число N – количество населенных пунктов (1 ≤ N ≤ 1000). Вторая строка содержит два числа A и B – номера начального и конечного пунктов. В третьей строке задается K – количество рейсов (0 ≤ K ≤ 1000). Следующие K строк содержат описания рейсов, по одному на строке. Каждое описание представляет собой четверку целых чисел. Первое число каждой четверки задает номер пункта отправления, второе – время отправления, третье – пункт назначения, четвертое – время прибытия. Номера пунктов – натуральные числа из диапазона от 1 до N. Пункт назначения и пункт отправления могут совпадать. Время измеряется в некоторых абсолютных единицах и задается целым числом, по модулю не превышающим 10^9. Поскольку рейсы совершаются на машинах времени, то время прибытия может быть как больше времени отправления, так и меньше, или равным ему.

Гарантируется, что входные данные таковы, что добраться из пункта A в пункт B всегда можно.

### Output format

Выведите минимальное время, когда вы сможете оказаться в пункте B.


## [Задача X - Pink Floyd](https://github.com/vinkalex/Algorithms-and-Data-structures-contest-1/blob/master/X.cpp)

Группа Pink Floyd собирается дать новый концертный тур по всему миру. По предыдущему опыту группа знает, что солист Роджер Уотерс постоянно нервничает при перелетах. На некоторых маршрутах он теряет вес от волнения, а на других — много ест и набирает вес.

Известно, что чем больше весит Роджер, тем лучше выступает группа, поэтому требуется спланировать перелеты так, чтобы вес Роджера на каждом концерте был максимально возможным. Группа должна посещать города в том же порядке, в котором она дает концерты. При этом между концертами группа может посещать промежуточные города.

### Input format

Первая строка входного файла содержит три натуральных числа n, m и k — количество городов в мире, количество рейсов и количество концертов, которые должна дать группа соответственно (n ≤ 100, m ≤ 10^4, 2 ≤ k ≤ 10^4). Города пронумерованы числами от 1 до n. Следующие m строк содержат описание рейсов, по одному на строке. Рейс номер i описывается тремя числами b_i, e_i и w_i — номер начального и конечного города рейса и предполагаемое изменение веса Роджера в миллиграммах (1 ≤ b_i, e_i ≤ n, −10^5 ≤ w_i ≤ 10^5). Последняя строка содержит числа a_1, a_2, ..., a_k — номера городов, в которых проводятся концерты. В начале концертного тура группа находится в городе a_1. Гарантируется, что группа может дать все концерты.

### Output format

Первая строка выходного файла должна содержать число s — количество рейсов, которые должна сделать группа. Вторая строка должна содержать s чисел — номера используемых рейсов. Если существует такая последовательность маршрутов между концертами, что Роджер будет набирать вес неограниченно, то первая строка выходного файла должна содержать строку “infinitely kind”.
